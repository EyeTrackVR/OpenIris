#include "helpers.hpp"

char* Helpers::itoa(int value, char* result, int base) {
  // check that the base if valid
  if (base < 2 || base > 36) {
    *result = '\0';
    return result;
  }

  char *ptr = result, *ptr1 = result, tmp_char;
  int tmp_value;

  do {
    tmp_value = value;
    value /= base;
    *ptr++ =
        "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxy"
        "z"[35 + (tmp_value - value * base)];
  } while (value);

  // Apply negative sign
  if (tmp_value < 0)
    *ptr++ = '-';
  *ptr-- = '\0';
  while (ptr1 < ptr) {
    tmp_char = *ptr;
    *ptr-- = *ptr1;
    *ptr1++ = tmp_char;
  }
  return result;
}

void split(const std::string& str,
           const std::string& splitBy,
           std::vector<std::string>& tokens) {
  /* Store the original string in the array, so we can loop the rest
   * of the algorithm. */
  tokens.emplace_back(str);

  // Store the split index in a 'size_t' (unsigned integer) type.
  size_t splitAt;
  // Store the size of what we're splicing out.
  size_t splitLen = splitBy.size();
  // Create a string for temporarily storing the fragment we're processing.
  std::string frag;
  // Loop infinitely - break is internal.
  while (true) {
    /* Store the last string in the vector, which is the only logical
     * candidate for processing. */
    frag = tokens.back();
    /* The index where the split is. */
    splitAt = frag.find(splitBy);
    // If we didn't find a new split point...
    if (splitAt == std::string::npos) {
      // Break the loop and (implicitly) return.
      break;
    }
    /* Put everything from the left side of the split where the string
     * being processed used to be. */
    tokens.back() = frag.substr(0, splitAt);
    /* Push everything from the right side of the split to the next empty
     * index in the vector. */
    tokens.emplace_back(
        frag.substr(splitAt + splitLen, frag.size() - (splitAt + splitLen)));
  }
}

std::vector<std::string> Helpers::split(const std::string& s, char delimiter) {
  std::vector<std::string> parts;
  std::string part;
  std::istringstream tokenStream(s);
  while (std::getline(tokenStream, part, delimiter)) {
    parts.push_back(part);
  }
  return parts;
}

void Helpers::update_progress_bar(int progress, int total) {
  int barWidth = 70;

  std::cout << "\r[";
  int pos = barWidth * progress / total;
  for (int i = 0; i < barWidth; ++i) {
    if (i < pos)
      std::cout << "=";
    else if (i == pos)
      std::cout << ">";
    else
      std::cout << " ";
  }
  std::cout << "] " << int(progress * 100.0 / total) << " %\r";
  std::cout.flush();
}